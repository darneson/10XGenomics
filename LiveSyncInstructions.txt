BRIEF LIVE SUBSET SYNC. INSTRUCTIONS from Shawn:
================================================

(1) A live subset sync. transfers a subset (including thumbnail
images and SAV information) of the raw runfolder that includes
all information relevant to your lane (as well as some statistical
information about other lanes on the same flow cell); it changes
in real time as the master (full) runfolder changes.  For modern
runs, the runfolder is generated by Illumina software (HCS and RTA)
installed on the instrument PC that controls the HiSeq instrument.
The exact file layout, format of binary files, etc. depends on
instrument PC software versions and has changed many times over
the Solexa/Illumina years.  It is the client user's responsibility
to either learn the appropriate details for direct interpretation,
or find, install, configure, and run appropriate software (e.g.,
some version of Illumina's BCL2FASTQ [that runs on Linux ---
Hoffman2 may be helpful], or the subtools inside it) to make
use of the information.  Note that ``conversion'' program
defaults may not be appropriate and may result in output not
equivalent to the Core `_qseq' files that Shawn will eventually
routinely generate for the lane (e.g., Illumina's BCL2FASTQ
defaults to ``EAMSS'' on [see (4) below for more information],
whereas Core QSEQs effectively have this off [which is actually
Illumina's current recommendation]; PF=0 reads may be hidden by
default; per-base quality scores below 2 may be raised to 2;
etc. --- note that ``conversion'' programs tend to do more
than literally convert, but also apply various filters and/
or transformations, usually at least partially controlled by
configuration options.)

If your lane submission form requested a lower degree of TruSeq-
style indexing than what the flow cell it was scheduled on is
actually physically sequencing with (e.g., you request none but
other lanes are 7-cycle single index, or you request 7-cycle
single index but other lanes are 8+8 cycle dual index), then
you will find ``extra'' cycles exist and you should ignore them.

Some runs (perhaps ~~5%) generate corrupted runfolders (e.g.,
most recently WB086), for a variety of reasons (RTA/HCS software
bugs, HiSeq instrument and/or reagent failures, instrument PC
hardware problems, hardware or software problems with Pan, etc.)
and to a variety of degrees (minor to severe).  Shawn identifies
and repairs such problems related to basecalls during usual Core
`_qseq' file generation, but realizing such exists and dealing
with it for a live subset sync. is the client user's responsibility.
Also, a fraction of runs are misnamed on the instrument; do not
be surprised if it appears the runfolder (e.g., experiment name
suffixed to the top level runfolder directory name, or the
`ExperimentName' XML value in the `runParameters.xml' file)
does not correspond to your lane's UCLA alphanumeric run name.


(2) If you don't already have a workflow that can handle raw
HiSeq runfolders, you will probably want to use Illumina's
BCL2FASTQ, as this is ``official'' software with documentation,
etc.  The current version is 1.8.4:

  https://support.illumina.com/downloads/bcl2fastq_conversion_software_184.ilmn

Their User's Guide (Adobe PDF document format) is at

  http://supportres.illumina.com/documents/documentation/software_documentation/bcl2fastq/bcl2fastq_letterbooklet_15038058brpmi.pdf

(PLEASE READ IT _FULLY_ AND _CAREFULLY_) and you will need to
install and be able to use the software on a Linux machine.
The campus Hoffman2 cluster may work as a platform for you.
An older version (1.8.3) is already installed on Hoffman2 below

  /u/local/apps/bcl2qfastq/1.8.3/gcc-4.4.6

e.g.,

  /u/local/apps/bcl2qfastq/1.8.3/gcc-4.4.6/bin/configureBclToFastq.pl

  /u/local/apps/bcl2qfastq/1.8.3/gcc-4.4.6/libexec/bcl2fastq-1.8.3/demultiplexBcls

  /u/local/apps/bcl2qfastq/1.8.3/gcc-4.4.6/bin/FastqConverter

although I have not tested that copy.  (Personally, on Hoffman2
I compile/install software fresh.)

Note that there are various ways to configure BCL2FASTQ (or its
component tools) with regards to index reads and demultiplexing,
e.g., you may just want index reads raw separately (as they are
given with Core `_qseq's), or you may want BCL2FASTQ to demultiplex
(it has only a limited repertoire of demux rules and configuration
options, and you need to compose and supply a ``sample sheet''
in Illumina format and provide particular command line options).


(3) When your live subset sync. is ready (which will be after the
flow cell the lane is on has physically started sequencing, but
before [e.g., 1 day before] the flow cell has finished sequencing),
you will receive an e-mail from Shawn with a credential similar to
that you already receive for Core `_qseq's, with a line inside like

  LVrfFiltVA068L6:abcdefgh

Use a RSYNC command similar to what you would use to pull Core
`_qseq's, e.g.,

  rsync <OPTIONS> <REMOTEfrom> <LOCALto>

where  <OPTIONS>  is

  --recursive --times --verbose --stats --progress --itemize-changes

and  <REMOTEfrom>  is

  rsync://LVrfFiltVA068L6@pan.pellegrini.mcdb.ucla.edu/LVrfFiltVA068L6/

and  <LOCALto>  is something like

  /local/path/to/where/you/want/live/subset/runfolder/VA068L6/

and `abcdefgh' is the response to give to the password prompt (or use
the RSYNC `--password-file' option if, e.g., you are scripting RSYNC).
This credential will generally be different than the one for the Core's
usual `_qseq's that Shawn will eventually generate for the lane.

The runfolder proper is the directory tree that has as its root a
directory with a name like `140606_SN971_0307_AH92LJADXX_Xap038'.
(The leading six digits are the YYMMDD start date on the instrument,
the `SN971' part gives the serial number of the instrument, the
`0307' part is a run serial number that is supposed to be unique
on the instrument, the `AH92LJADXX' decomposes as `A' + `H92LJADXX'
which corresponds to this run occurring on the `A' side of our dual
side [HiSeq 2000/2500] instruments [vs. `B' side] and flow cell
serial number, and the `Xap038' is the UCLA alphanumeric run name
[which is occasionally wrong].)

You may start this RSYNC anytime after you receive the live subset
sync. credentials.  If you run this RSYNC before the run has physically
finished sequencing and the instrument PC has (apparently) finished
runfolder generation and network transfer, then it will retrieve an
incomplete subsetted runfolder, and you will need to incrementally
sync. again (as many times as you wish) later.  Each time you sync.
while the run is incomplete (and assuming you are keeping whatever
partial copy you get on the local side each time, and using the same
RSYNC invocation each time), you will ``catch up'' to the realtime
runfolder contents.

If you eventually have a sync. (that completes without errors) that
results in a file named `RTAComplete.txt' at the top level of the
runfolder, then HCS/RTA on the instrument PC and network transfer
to Pan (and you) are apparently complete and you can proceed to try
using your copy of the subsetted runfolder.  (Files with names like
`Basecalling_Netcopy_complete.txt', `Basecalling_Netcopy_complete_Read1.txt',
`ImageAnalysis_Netcopy_complete.txt', etc. are NOT indications that
the runfolder is ready.)  Note that this is only an apparent indication,
as, e.g., some failed runs that can be recovered by re-hybridizing
the flow cell, RTA bugs, etc. can result in this file being created
but the runfolder not being final (but you would in time get notice
from us if this happens).

The number of files in a runfolder (even a subsetted one) will be
huge compared to what you are used to for Core `_qseq's (where there
is just one file per tile per logical end).

For the near and medium-term future, you must complete your final
live subset sync. within 24 hours of the `RTAComplete.txt' file's
coming into existence/timestamp.  This is because once the process
of archiving the run and making Core `_qseq's for it begins, all live
subset syncs. on the flow cell will become permanently inaccessible
(and you will have to wait for Core `_qseq's if your live sync. is
incomplete).  Ideally, you need to e-mail Shawn when your final sync.
is complete, as otherwise Shawn cannot begin Core `_qseq' generation
for other users on the flow cell until the 24 hours elapses.  Note
that Shawn will proceed to generate usual Core `_qseq's and credentials
for all lanes --- no matter if live sync. (no matter if e-mail
completed notification from you or not), or without live sync.
Core `_qseq's remain the files of record in all cases.


(4) The largest difference you might notice if you use, e.g., Illumina
BCL2FASTQ with default options (not recommended) to convert when
compared to Core `_qseq's is ``EAMSS'' filtering --- a.k.a. ``Read
Segment Quality control metric'' --- which likely defaults on in
BCL2FASTQ *even though current Illumina documentation recommends
EAMSS be off* (e.g., see pages 15 and 17 in their ``bcl2fastq v1.8.4
User Guide'').  Output when off more closely reflects the `.bcl'
binary basecall files in the raw runfolder.  EAMSS was kind of a
hack that some of the Illumina software (e.g., BCL2FASTQ, but not
MiSeq or BaseSpace[?]) did/does (by default) to try to downplay the
Illumina platform `G'-quenching issue; an overview follows below.

The Illumina platform has a fairly well-known problem with sequencing
`G'-rich motifs.  The phenomenon is known as ```G'-quenching'';
apparently `G's act locally to inhibit Illumina's fluorophore-tagged
nucleotides from glowing, with the result that the camera sees dimmer
colonies (heading toward blackness) in `G'-rich motifs and RTA
is more likely to make basecall errors there in particular ways.
For some reason, RTA's Q-score tables have not modeled this as
well as they might for some combinations of sequencing chemistry,
instrument versions (and perhaps secret versions, e.g., the variety
of cameras in instruments all nominally called ``HiSeq 2500''s),
library types, software versions, etc.  EAMSS appears to be a post-
RTA hack that Illumina put in some of its software (but not all
of it) to replace quality scores near these motifs with all very
bad quality scores (Q=2's) to sometimes help downstream applications
that might be sensitive to this but don't model it themselves.
(Many workflows are not terribly affected, e.g., alignment-for-
position-based ones.  The only known example is certain usage
patterns of Broad GATK for variant calling.)  Illumina currently
recommends that EAMSS _NOT_ be used (even though some of their
software defaults to it being on), maybe because they have been
working on their chemistry lately to try to reduce the problem
from happening too badly in the first place, or because RTA updates
have more realistic average Q-score lookup tables.

EAMSS as of OLB 1.9 (by direct examination of source code version 1.3
of `c++/basecalling/MaskQvalsByEamss.cpp') is as follows: given an
uppercase A/C/G/T/... basecall string and the corresponding Phred
with ASCII shift +64 quality scores string, applying EAMSS leaves
the basecalls alone and potentially modifies the quality score string
in a process described in the following two paragraphs.

Part 1: Consider all non-empty suffixes of the Q-string (from just
one character to the entire Q-string); score each by (# Q14[`N']
and below) - 2*(# Q30[`^'] and above).  Keep only the very longest
of the maximum-scoring ones.  If the highest score is negative or
zero, do nothing (Q-string remains unmodified; all done).  Otherwise,
replace all characters in the Q-string from the first base of the
``winning'' (bad) suffix, including it, to the last base, including
it, with `B's (Q=2), and proceed to Part 2.

Part 2: Consider all non-empty contiguous substrings of the basecalls
that end at (and include) the first base of the winning Q-string suffix
from Part 1 (and start as early as the very first base, first base
included) and that are at least 10 bases long.  (There may be none.)
Take these one at a time in order of increasing length, stopping early
(and not including) the first one that has <90% of its basecalls
being literally `G'.  Next, discard all those that don't start with
a literal `G'.  If there are any left, extend the Q-string masking:
replace all Q-string characters from where the longest one left
has its first base (including this base) to the very last character
(including it) with `B's (Q=2).

If you want to apply EAMSS to Core `_qseq's, I can provide you with
code/scripts to do so.
